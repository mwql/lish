<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Photographer Gallery — Auto View</title>
  <style>
    :root{
      --bg:#0f0f10;
      --card-bg: rgba(255,255,255,0.03);
      --dot-active: #fff;
      --dot-inactive: #666;
      --gap: 18px;
    }
    html,body{
      height:100%;
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg,var(--bg), #050506 120%);
      color:#fff;
    }

    /* outer stage centered vertically + horizontally */
    .stage{
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:36px;
      box-sizing:border-box;
    }

    /* gallery card */
    .gallery-card{
      width:min(1100px, 94vw);
      background:var(--card-bg);
      border-radius:10px;
      padding:18px;
      box-sizing:border-box;
      box-shadow: 0 6px 30px rgba(0,0,0,0.6);
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:center;
    }

    header{
      width:100%;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    header h1{
      margin:0;
      font-size:18px;
      letter-spacing:0.3px;
    }
    header p{ margin:0; opacity:0.75; font-size:13px }

    /* viewport keeps gallery centered horizontally and hides overflow */
    .viewport{
      width:100%;
      height:420px;
      max-height:60vh;
      overflow:hidden;
      position:relative;
      border-radius:8px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.1));
      display:flex;
      align-items:center;
      justify-content:center;
    }

    /* horizontal track */
    .track{
      display:flex;
      gap:var(--gap);
      align-items:center;
      transition:transform 600ms cubic-bezier(.22,.9,.3,1);
      will-change:transform;
      padding:18px;
      box-sizing:border-box;
      /* for touch scrolling fallback */
      touch-action: pan-y;
    }

    .slide{
      flex: 0 0 auto; /* keep natural width */
      width: min(700px, 80vw);
      height: calc(100% - 36px);
      background:#111;
      border-radius:6px;
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      box-shadow: 0 6px 20px rgba(0,0,0,0.6);
    }
    .slide img{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
      user-select:none;
      -webkit-user-drag:none;
      pointer-events:none;
    }

    /* controls */
    .controls{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .btn{
      background:transparent;
      border:1px solid rgba(255,255,255,0.08);
      color:#fff;
      padding:8px 12px;
      border-radius:6px;
      cursor:pointer;
      font-size:14px;
      backdrop-filter: blur(4px);
    }
    .btn:active{ transform:translateY(1px) }

    /* pagination dots */
    .dots{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .dot{
      width:10px;
      height:10px;
      border-radius:50%;
      background:var(--dot-inactive);
      cursor:pointer;
      opacity:0.95;
    }
    .dot.active{ background:var(--dot-active); transform:scale(1.12) }

    /* small screens adjustments */
    @media (max-width:640px){
      .viewport{ height:60vh }
      .slide{ width:90vw }
    }
  </style>
</head>
<body>

  <div class="stage">
    <div class="gallery-card" aria-roledescription="carousel">
      <header>
        <div>
          <h1>I am a photographer — gallery</h1>
          <p>Auto view mode — photos from <code>img/</code></p>
        </div>
        <div class="controls" aria-hidden="false">
          <button class="btn" id="prevBtn" title="Previous (←)">Prev</button>
          <button class="btn" id="playPauseBtn" title="Pause/Play">Pause</button>
          <button class="btn" id="nextBtn" title="Next (→)">Next</button>
        </div>
      </header>

      <div class="viewport" id="viewport" tabindex="0">
        <div class="track" id="track">
          <!-- Add your images here. The example below assumes files like img/photo1.jpg, img/photo2.jpg ... -->
          <!-- Replace, remove or add <figure> blocks as needed for your actual filenames. -->
          <figure class="slide"><img src="img/photo1.jpg" alt="Photo 1" loading="lazy"></figure>
          <figure class="slide"><img src="img/photo2.jpg" alt="Photo 2" loading="lazy"></figure>
          <figure class="slide"><img src="img/photo3.jpg" alt="Photo 3" loading="lazy"></figure>
          <figure class="slide"><img src="img/photo4.jpg" alt="Photo 4" loading="lazy"></figure>
          <figure class="slide"><img src="img/photo5.jpg" alt="Photo 5" loading="lazy"></figure>
          <!-- If you want to add more: <figure class="slide"><img src="img/yourfilename.jpg" alt="..."></figure> -->
        </div>
      </div>

      <div style="width:100%; display:flex; justify-content:space-between; align-items:center; margin-top:10px;">
        <small style="opacity:0.75">Tip: hover to pause · swipe on touch · keyboard ← →</small>
        <div class="dots" id="dots" aria-hidden="false"></div>
      </div>
    </div>
  </div>

  <script>
    (function () {
      const track = document.getElementById('track');
      const slides = Array.from(track.querySelectorAll('.slide'));
      const prevBtn = document.getElementById('prevBtn');
      const nextBtn = document.getElementById('nextBtn');
      const playPauseBtn = document.getElementById('playPauseBtn');
      const dotsWrap = document.getElementById('dots');
      const viewport = document.getElementById('viewport');

      if (!slides.length) {
        track.innerHTML = '<div style="padding:30px;color:#ddd">No images found. Add images into <code>img/</code> and add <code>&lt;figure class=\"slide\"&gt;...&lt;/figure&gt;</code> blocks.</div>';
        return;
      }

      // create dots
      slides.forEach((_, i) => {
        const d = document.createElement('div'); d.className = 'dot'; d.dataset.index = i;
        d.addEventListener('click', () => goTo(i));
        dotsWrap.appendChild(d);
      });
      const dots = Array.from(dotsWrap.children);

      let index = 0;
      let autoTimer = null;
      const AUTOPLAY_DELAY = 3000; // ms

      function updateUI() {
        // compute center offset so the active slide is centered in viewport
        const vpRect = viewport.getBoundingClientRect();
        const slide = slides[index];
        const slideRect = slide.getBoundingClientRect();
        // current track translate to place the slide centered
        const trackRect = track.getBoundingClientRect();
        // compute center X of viewport minus center X of slide relative to track
        const vpCenter = vpRect.left + vpRect.width / 2;
        const slideCenter = slideRect.left + slideRect.width / 2;
        const delta = vpCenter - slideCenter;
        // current transform + delta
        // simpler: compute desired translateX by summing slide offsets
        let offsetLeft = 0;
        for (let i = 0; i < index; i++) offsetLeft += slides[i].offsetWidth + parseInt(getComputedStyle(track).gap || 0);
        const target = (vpRect.width - slides[index].offsetWidth) / 2 - offsetLeft;
        track.style.transform = `translateX(${target}px)`;
        dots.forEach((d, i) => d.classList.toggle('active', i === index));
      }

      function goTo(i) {
        index = (i + slides.length) % slides.length;
        updateUI();
      }
      function next() { goTo(index + 1); }
      function prev() { goTo(index - 1); }

      function play() {
        stop();
        autoTimer = setInterval(next, AUTOPLAY_DELAY);
        playPauseBtn.textContent = 'Pause';
        playPauseBtn.dataset.playing = 'true';
      }
      function stop() {
        if (autoTimer) { clearInterval(autoTimer); autoTimer = null; }
        playPauseBtn.textContent = 'Play';
        playPauseBtn.dataset.playing = 'false';
      }
      function togglePlay() {
        if (autoTimer) stop(); else play();
      }

      // controls
      prevBtn.addEventListener('click', () => { prev(); resetAutoplay(); });
      nextBtn.addEventListener('click', () => { next(); resetAutoplay(); });
      playPauseBtn.addEventListener('click', togglePlay);

      // pause on hover/focus
      viewport.addEventListener('mouseenter', () => { stop(); });
      viewport.addEventListener('mouseleave', () => { play(); });

      // keyboard
      window.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') { prev(); resetAutoplay(); }
        if (e.key === 'ArrowRight') { next(); resetAutoplay(); }
        if (e.key === ' ' || e.key === 'Spacebar') { e.preventDefault(); togglePlay(); }
      });

      // touch swipe
      (function addTouch() {
        let startX = 0, dx = 0, touching = false;
        viewport.addEventListener('touchstart', (ev) => {
          touching = true; stop();
          startX = ev.touches[0].clientX;
        }, {passive:true});
        viewport.addEventListener('touchmove', (ev) => {
          if (!touching) return;
          dx = ev.touches[0].clientX - startX;
          track.style.transition = 'none';
          track.style.transform = `translateX(${(parseFloat(track.style.transform.replace('translateX(', '') ) || 0) + dx}px)`;
        }, {passive:true});
        viewport.addEventListener('touchend', (ev) => {
          touching = false; track.style.transition = '';
          if (Math.abs(dx) > 40) {
            if (dx < 0) next(); else prev();
          } else {
            updateUI();
          }
          dx = 0; play();
        }, {passive:true});
      })();

      // adjust on resize
      window.addEventListener('resize', () => {
        updateUI();
      });

      // helper to restart autoplay after manual interaction
      let interactionTimeout = null;
      function resetAutoplay() {
        stop();
        if (interactionTimeout) clearTimeout(interactionTimeout);
        interactionTimeout = setTimeout(() => play(), 5000); // restart auto after 5s
      }

      // initial setup: wait for images to load to compute sizes then position
      function waitImagesThenInit() {
        const imgs = Array.from(track.querySelectorAll('img'));
        let loaded = 0;
        if (!imgs.length) { updateUI(); play(); return; }
        imgs.forEach(img => {
          if (img.complete) { loaded++; }
          else img.addEventListener('load', () => { loaded++; if (loaded === imgs.length) init(); });
          img.addEventListener('error', () => { loaded++; if (loaded === imgs.length) init(); });
        });
        if (loaded === imgs.length) init();
      }

      function init() {
        // ensure track has no leftover inline transform
        track.style.transform = '';
        // small timeout to let layout finalize
        requestAnimationFrame(() => {
          updateUI();
          play();
        });
      }

      waitImagesThenInit();
    })();
  </script>
</body>
</html>
